<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üïâÔ∏è Rig Veda Mood Explorer</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Noto+Serif+Devanagari:wght@400;600&display=swap" rel="stylesheet">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background: #0A0E27;
            color: #fff;
            overflow: hidden;
        }
        
        .devanagari {
            font-family: 'Noto Serif Devanagari', serif;
        }
        
        #network-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        .node {
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .node:hover {
            transform: scale(1.15);
            filter: drop-shadow(0 0 8px currentColor);
        }
        
        .node.active {
            transform: scale(1.3);
            animation: pulse 0.6s ease-in-out 3;
        }
        
        .link {
            stroke: rgba(255, 255, 255, 0.3);
            stroke-width: 1px;
            transition: all 0.3s ease;
        }
        
        .link.active {
            stroke: #D4AF37;
            stroke-width: 2px;
            opacity: 0.8;
            filter: drop-shadow(0 0 4px #D4AF37);
        }
        
        .link.faded {
            opacity: 0.05;
        }
        
        .node.faded {
            opacity: 0.2;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1.3); }
            50% { transform: scale(1.5); }
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @keyframes pulseOpacity {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .loading-spinner {
            animation: spin 1.5s linear infinite, pulseOpacity 1.5s ease-in-out infinite;
            font-size: 4rem;
        }
        
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .modal-overlay.show {
            opacity: 1;
        }
        
        .modal-content {
            background: linear-gradient(135deg, #1a1f3a, #0f1229);
            border: 1px solid rgba(212, 175, 55, 0.3);
            border-radius: 16px;
            padding: 2rem;
            max-width: 700px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            transform: scale(0.9);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }
        
        .modal-overlay.show .modal-content {
            transform: scale(1);
        }
        
        .tag-pill {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            background: rgba(212, 175, 55, 0.2);
            border: 1px solid rgba(212, 175, 55, 0.4);
            border-radius: 12px;
            font-size: 0.875rem;
            margin: 0.25rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .tag-pill:hover {
            background: rgba(212, 175, 55, 0.3);
            transform: translateY(-2px);
        }
        
        .autocomplete {
            position: absolute;
            background: #1a1f3a;
            border: 1px solid rgba(212, 175, 55, 0.3);
            border-radius: 8px;
            margin-top: 0.5rem;
            max-height: 300px;
            overflow-y: auto;
            z-index: 100;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            width: 100%;
        }
        
        .autocomplete-item {
            padding: 0.75rem 1rem;
            cursor: pointer;
            transition: background 0.2s ease;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .autocomplete-item:hover {
            background: rgba(212, 175, 55, 0.2);
        }
        
        .legend {
            position: fixed;
            bottom: 2rem;
            left: 2rem;
            background: rgba(26, 31, 58, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(212, 175, 55, 0.3);
            border-radius: 12px;
            padding: 1rem;
            z-index: 50;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin: 0.5rem 0;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .legend-item:hover {
            transform: translateX(4px);
        }
        
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
        }
        
        .network-controls {
            position: fixed;
            top: 6rem;
            right: 2rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            z-index: 50;
        }
        
        .control-btn {
            background: rgba(26, 31, 58, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(212, 175, 55, 0.3);
            color: #D4AF37;
            width: 40px;
            height: 40px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 600;
        }
        
        .control-btn:hover {
            background: rgba(26, 31, 58, 1);
            transform: scale(1.1);
        }
        
        @media (max-width: 768px) {
            .modal-content {
                width: 100%;
                height: 100%;
                max-height: 100vh;
                border-radius: 0;
                padding: 1.5rem;
            }
            
            .legend {
                bottom: 1rem;
                left: 1rem;
                font-size: 0.875rem;
            }
            
            .network-controls {
                top: 5rem;
                right: 1rem;
            }
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #D4AF37, #FFD93D);
            color: #0A0E27;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
        }
        
        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(212, 175, 55, 0.4);
        }
        
        .btn-primary:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        .btn-secondary {
            background: rgba(212, 175, 55, 0.2);
            color: #D4AF37;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            border: 1px solid rgba(212, 175, 55, 0.4);
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
        }
        
        .btn-secondary:hover:not(:disabled) {
            background: rgba(212, 175, 55, 0.3);
            transform: translateY(-2px);
        }

        .btn-secondary:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        .tooltip {
            position: absolute;
            background: rgba(26, 31, 58, 0.95);
            border: 1px solid rgba(212, 175, 55, 0.5);
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-size: 0.875rem;
            pointer-events: none;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        
        .tooltip.show {
            opacity: 1;
        }

        .hidden {
            display: none !important;
        }

        .network-label {
            font-size: 10px;
            pointer-events: none;
            user-select: none;
        }
    </style>
</head>
<body>
    <div id="app">
        <header class="fixed top-0 left-0 right-0 bg-gradient-to-r from-indigo-900/50 to-purple-900/50 backdrop-blur-md border-b border-yellow-600/30 z-40">
            <div class="container mx-auto px-4 py-4">
                <h1 class="text-2xl font-semibold text-center mb-3">üïâÔ∏è Rig Veda Mood Explorer</h1>
                <div class="max-w-2xl mx-auto relative">
                    <input 
                        type="text" 
                        id="search-input" 
                        placeholder="Search by deity, mood, or tag..." 
                        class="w-full px-4 py-2 rounded-lg bg-white/10 border border-yellow-600/30 text-white placeholder-gray-400 focus:outline-none focus:border-yellow-500 transition"
                    />
                    <div id="autocomplete" class="autocomplete hidden"></div>
                </div>
            </div>
        </header>

        <div id="network-container"></div>

        <div class="legend">
            <div class="legend-item" data-type="deity">
                <div class="legend-color" style="background: linear-gradient(135deg, #FF6B6B, #FF8E53);"></div>
                <span>üî¥ Deities</span>
            </div>
            <div class="legend-item" data-type="mood">
                <div class="legend-color" style="background: linear-gradient(135deg, #FFD93D, #D4AF37);"></div>
                <span>üü° Moods</span>
            </div>
            <div class="legend-item" data-type="tag">
                <div class="legend-color" style="background: linear-gradient(135deg, #4A90E2, #6BCB77);"></div>
                <span>üîµ Tags</span>
            </div>
            <div class="legend-item" data-type="verse">
                <div class="legend-color" style="background: #F5F5F5; border: 2px solid #D4AF37;"></div>
                <span>‚ö™ Verses</span>
            </div>
            <button id="reset-filter" class="btn-secondary w-full mt-2 hidden text-sm">Reset Filter</button>
        </div>

        <div class="network-controls">
            <button class="control-btn" id="zoom-in">+</button>
            <button class="control-btn" id="zoom-out">‚àí</button>
            <button class="control-btn" id="reset-view" style="width: auto; padding: 0 0.75rem;">‚Ü∫</button>
        </div>

        <div id="loading" class="fixed inset-0 flex items-center justify-center flex-col gap-4 z-50 bg-gradient-to-br from-indigo-900 to-purple-900">
            <div class="loading-spinner">üïâÔ∏è</div>
            <div id="loading-text" class="text-xl">Loading Rig Veda...</div>
        </div>

        <div id="modal" class="modal-overlay" style="display: none;">
            <div class="modal-content">
                <button id="close-modal" class="absolute top-4 right-4 text-3xl text-gray-400 hover:text-white transition">&times;</button>
                <div id="modal-header" class="text-center mb-4 text-lg text-yellow-500"></div>
                <div id="modal-tags" class="flex flex-wrap justify-center mb-6"></div>
                <div id="modal-devanagari" class="devanagari text-3xl text-center mb-4 leading-relaxed"></div>
                <div id="modal-transliteration" class="italic text-gray-400 text-xl text-center mb-6"></div>
                <div id="modal-translation" class="text-lg leading-relaxed mb-8"></div>
                <div class="flex gap-3 justify-center items-center flex-wrap">
                    <button id="prev-verse" class="btn-secondary">‚Üê Previous</button>
                    <button id="random-verse" class="btn-primary">üé≤ Dice of Destiny</button>
                    <button id="next-verse" class="btn-secondary">Next ‚Üí</button>
                </div>
            </div>
        </div>

        <div class="tooltip" id="tooltip"></div>
    </div>

    <script>
        let verses = [];
        let searchIndex = {
            deities: new Map(),
            moods: new Map(),
            tags: new Map()
        };
        let networkData = { nodes: [], links: [] };
        let simulation;
        let svg, g, link, node, labels;
        let currentVerse = null;
        let selectedNode = null;
        let isMobile = window.innerWidth < 768;
        let driftAnimationFrame = null;
        let lastTouchTime = 0;
        let transform = d3.zoomIdentity;
        let zoomBehavior;
        
        const deityEmojis = {
            'Agni': 'üî•', 'Indra': '‚ö°', 'Soma': 'üåô', 'Ushas': 'üåÖ', 
            'Vayu': 'üí®', 'Varuna': 'üåä', 'Surya': '‚òÄÔ∏è', 'Vishnu': 'ü¶Ö',
            'Rudra': 'üèπ', 'Maruts': '‚õàÔ∏è', 'Ashvins': 'üêé', 'Sarasvati': 'üìø'
        };
        
        const moodEmojis = {
            'invocatory': 'üôè', 'praise': '‚ú®', 'contemplative': 'üí≠',
            'devotional': 'üïâÔ∏è', 'descriptive': 'üìñ', 'ritualistic': 'üî±',
            'philosophical': 'üßò', 'narrative': 'üìú'
        };

        async function loadData() {
            try {
                document.getElementById('loading-text').textContent = 'Loading verses...';
                const response = await fetch('./rigveda_data.json');
                if (!response.ok) throw new Error('Failed to load data');
                verses = await response.json();
                
                if (!Array.isArray(verses) || verses.length === 0) {
                    throw new Error('Invalid data format');
                }
                
                document.getElementById('loading-text').textContent = 'Building search index...';
                await new Promise(resolve => setTimeout(resolve, 100));
                buildSearchIndex();
                
                document.getElementById('loading-text').textContent = 'Creating network...';
                await new Promise(resolve => setTimeout(resolve, 100));
                createNetwork();
                
                document.getElementById('loading').style.display = 'none';
            } catch (error) {
                console.error('Error loading data:', error);
                document.getElementById('loading').innerHTML = `
                    <div class="text-center">
                        <p class="text-xl mb-4">Unable to load data. Please ensure rigveda_data.json is present.</p>
                        <button onclick="location.reload()" class="btn-primary">Retry</button>
                    </div>
                `;
            }
        }

        function buildSearchIndex() {
            verses.forEach(verse => {
                if (verse.deity) {
                    searchIndex.deities.set(verse.deity, (searchIndex.deities.get(verse.deity) || 0) + 1);
                }
                if (verse.mood) {
                    searchIndex.moods.set(verse.mood, (searchIndex.moods.get(verse.mood) || 0) + 1);
                }
                if (verse.tags && Array.isArray(verse.tags)) {
                    verse.tags.forEach(tag => {
                        searchIndex.tags.set(tag, (searchIndex.tags.get(tag) || 0) + 1);
                    });
                }
            });
        }

        function createNetwork() {
            const nodes = [];
            const links = [];
            const nodeMap = new Map();
            
            searchIndex.deities.forEach((count, deity) => {
                const id = `deity-${deity}`;
                nodes.push({ id, type: 'deity', label: deity, count });
                nodeMap.set(id, nodes[nodes.length - 1]);
            });
            
            searchIndex.moods.forEach((count, mood) => {
                const id = `mood-${mood}`;
                nodes.push({ id, type: 'mood', label: mood, count });
                nodeMap.set(id, nodes[nodes.length - 1]);
            });
            
            searchIndex.tags.forEach((count, tag) => {
                const id = `tag-${tag}`;
                nodes.push({ id, type: 'tag', label: tag, count });
                nodeMap.set(id, nodes[nodes.length - 1]);
            });
            
            const verseLimit = Math.min(verses.length, 300);
            const sampleVerses = verses
                .sort(() => Math.random() - 0.5)
                .slice(0, verseLimit);
            
            sampleVerses.forEach((verse) => {
                const id = `verse-${verse.mandala}-${verse.sukta}-${verse.verse}`;
                nodes.push({ id, type: 'verse', verse });
                nodeMap.set(id, nodes[nodes.length - 1]);
                
                if (verse.deity && nodeMap.has(`deity-${verse.deity}`)) {
                    links.push({ source: id, target: `deity-${verse.deity}` });
                }
                if (verse.mood && nodeMap.has(`mood-${verse.mood}`)) {
                    links.push({ source: id, target: `mood-${verse.mood}` });
                }
                if (verse.tags && Array.isArray(verse.tags)) {
                    verse.tags.forEach(tag => {
                        if (nodeMap.has(`tag-${tag}`)) {
                            links.push({ source: id, target: `tag-${tag}` });
                        }
                    });
                }
            });
            
            const tagArray = Array.from(searchIndex.tags.keys());
            tagArray.forEach((tag1, i) => {
                tagArray.slice(i + 1).forEach(tag2 => {
                    const sharedVerses = verses.filter(v => 
                        v.tags && v.tags.includes(tag1) && v.tags.includes(tag2)
                    );
                    if (sharedVerses.length >= 2) {
                        links.push({
                            source: `tag-${tag1}`,
                            target: `tag-${tag2}`,
                            strength: Math.min(sharedVerses.length / 5, 2)
                        });
                    }
                });
            });
            
            const moodArray = Array.from(searchIndex.moods.keys());
            moodArray.forEach((mood1, i) => {
                moodArray.slice(i + 1).forEach(mood2 => {
                    const sharedDeities = verses.filter(v => 
                        (v.mood === mood1 || v.mood === mood2) && v.deity
                    ).map(v => v.deity);
                    const uniqueDeities = new Set(sharedDeities);
                    if (uniqueDeities.size >= 2) {
                        links.push({
                            source: `mood-${mood1}`,
                            target: `mood-${mood2}`,
                            strength: 0.5
                        });
                    }
                });
            });
            
            networkData = { nodes, links };
            initializeVisualization();
        }

        function initializeVisualization() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            networkData.nodes.forEach(node => {
                node.x = Math.random() * width;
                node.y = Math.random() * height;
            });
            
            svg = d3.select('#network-container')
                .append('svg')
                .attr('width', width)
                .attr('height', height);
            
            const defs = svg.append('defs');
            
            const deityGradient = defs.append('linearGradient')
                .attr('id', 'deity-gradient')
                .attr('x1', '0%').attr('y1', '0%')
                .attr('x2', '100%').attr('y2', '100%');
            deityGradient.append('stop').attr('offset', '0%').attr('stop-color', '#FF6B6B');
            deityGradient.append('stop').attr('offset', '100%').attr('stop-color', '#FF8E53');
            
            const moodGradient = defs.append('linearGradient')
                .attr('id', 'mood-gradient')
                .attr('x1', '0%').attr('y1', '0%')
                .attr('x2', '100%').attr('y2', '100%');
            moodGradient.append('stop').attr('offset', '0%').attr('stop-color', '#FFD93D');
            moodGradient.append('stop').attr('offset', '100%').attr('stop-color', '#D4AF37');
            
            const tagGradient = defs.append('linearGradient')
                .attr('id', 'tag-gradient')
                .attr('x1', '0%').attr('y1', '0%')
                .attr('x2', '100%').attr('y2', '100%');
            tagGradient.append('stop').attr('offset', '0%').attr('stop-color', '#4A90E2');
            tagGradient.append('stop').attr('offset', '100%').attr('stop-color', '#6BCB77');
            
            zoomBehavior = d3.zoom()
                .scaleExtent([0.1, 4])
                .on('zoom', (event) => {
                    transform = event.transform;
                    g.attr('transform', transform);
                });
            
            svg.call(zoomBehavior);
            
            g = svg.append('g');
            
            simulation = d3.forceSimulation(networkData.nodes)
                .force('link', d3.forceLink(networkData.links).id(d => d.id).distance(d => d.strength ? 40 : 30))
                .force('charge', d3.forceManyBody().strength(-50))
                .force('collide', d3.forceCollide().radius(15))
                .force('x', d3.forceX(width / 2).strength(0.05))
                .force('y', d3.forceY(height / 2).strength(0.05));
            
            link = g.append('g')
                .selectAll('line')
                .data(networkData.links)
                .join('line')
                .attr('class', 'link');
            
            node = g.append('g')
                .selectAll('circle')
                .data(networkData.nodes)
                .join('circle')
                .attr('class', 'node')
                .attr('r', d => {
                    if (d.type === 'deity') return 8;
                    if (d.type === 'mood') return 7;
                    if (d.type === 'tag') return 6;
                    return 4;
                })
                .attr('fill', d => {
                    if (d.type === 'deity') return 'url(#deity-gradient)';
                    if (d.type === 'mood') return 'url(#mood-gradient)';
                    if (d.type === 'tag') return 'url(#tag-gradient)';
                    return '#F5F5F5';
                })
                .attr('stroke', d => d.type === 'verse' ? '#D4AF37' : 'none')
                .attr('stroke-width', 1)
                .on('click', handleNodeClick)
                .on('mouseenter', handleNodeHover)
                .on('mouseleave', hideTooltip)
                .call(d3.drag()
                    .on('start', dragStarted)
                    .on('drag', dragged)
                    .on('end', dragEnded));
            
            labels = g.append('g')
                .selectAll('text')
                .data(networkData.nodes.filter(d => d.type !== 'verse'))
                .join('text')
                .attr('class', 'network-label')
                .text(d => d.label.length > 12 ? d.label.slice(0, 12) + '...' : d.label)
                .style('font-size', '10px')
                .style('fill', d => {
                    if (d.type === 'deity') return '#FF8E53';
                    if (d.type === 'mood') return '#FFD93D';
                    if (d.type === 'tag') return '#6BCB77';
                    return '#F5F5F5';
                })
                .style('opacity', 0.7)
                .style('pointer-events', 'none')
                .style('user-select', 'none');
            
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
                
                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);
                
                labels
                    .attr('x', d => d.x + 10)
                    .attr('y', d => d.y + 3);
            });
            
            if (isMobile) {
                startMobileDrift();
            }
        }

        function handleNodeClick(event, d) {
            event.stopPropagation();
            
            if (d.type === 'verse') {
                openVerseModal(d.verse);
            } else {
                if (selectedNode === d) {
                    resetView();
                } else {
                    highlightNode(d);
                }
            }
        }

        function highlightNode(d) {
            selectedNode = d;
            
            const connectedNodes = new Set();
            const connectedLinks = new Set();
            
            networkData.links.forEach(l => {
                const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
                const targetId = typeof l.target === 'object' ? l.target.id : l.target;
                
                if (sourceId === d.id || targetId === d.id) {
                    connectedLinks.add(l);
                    connectedNodes.add(sourceId);
                    connectedNodes.add(targetId);
                }
            });
            
            node.classed('active', n => n.id === d.id)
                .classed('faded', n => !connectedNodes.has(n.id));
            
            link.classed('active', l => connectedLinks.has(l))
                .classed('faded', l => !connectedLinks.has(l));
            
            document.getElementById('reset-filter').classList.remove('hidden');
        }

        function resetView() {
            selectedNode = null;
            node.classed('active', false).classed('faded', false);
            link.classed('active', false).classed('faded', false);
            hideTooltip();
            document.getElementById('reset-filter').classList.add('hidden');
        }

        function handleNodeHover(event, d) {
            if (!isMobile && d.type !== 'verse') {
                const label = d.label || '';
                const count = d.count ? ` (${d.count} verses)` : '';
                showTooltip(event, label + count);
            }
        }

        function showTooltip(event, text) {
            const tooltip = d3.select('#tooltip');
            tooltip
                .style('left', (event.pageX + 10) + 'px')
                .style('top', (event.pageY + 10) + 'px')
                .text(text)
                .classed('show', true);
        }

        function hideTooltip() {
            d3.select('#tooltip').classed('show', false);
        }

        function dragStarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragEnded(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        function startMobileDrift() {
            let startTime = Date.now();
            
            function drift() {
                const now = Date.now();
                const elapsed = (now - startTime) / 1000;
                const timeSinceTouch = (now - lastTouchTime) / 1000;
                
                if (timeSinceTouch > 3) {
                    const offsetX = Math.sin(elapsed * 0.5) * 20;
                    const offsetY = Math.cos(elapsed * 0.3) * 15;
                    
                    const newTransform = d3.zoomIdentity
                        .translate(offsetX, offsetY)
                        .scale(transform.k);
                    
                    svg.call(zoomBehavior.transform, newTransform);
                }
                
                driftAnimationFrame = requestAnimationFrame(drift);
            }
            
            driftAnimationFrame = requestAnimationFrame(drift);
        }

        function openVerseModal(verse) {
            if (!verse) return;
            
            currentVerse = verse;
            
            document.getElementById('modal-header').textContent = 
                `Mandala ${verse.mandala} ‚Ä¢ Sukta ${verse.sukta} ‚Ä¢ Verse ${verse.verse}`;
            
            const tags = [];
            if (verse.deity) tags.push({ label: verse.deity, type: 'deity' });
            if (verse.mood) tags.push({ label: verse.mood, type: 'mood' });
            if (verse.categorization) tags.push({ label: verse.categorization, type: 'category' });
            if (verse.tags && Array.isArray(verse.tags)) {
                verse.tags.forEach(t => tags.push({ label: t, type: 'tag' }));
            }
            
            document.getElementById('modal-tags').innerHTML = tags
                .map(t => `<span class="tag-pill" data-type="${t.type}" data-label="${t.label}">${t.label}</span>`)
                .join('');
            
            document.getElementById('modal-devanagari').textContent = verse.devanagari || '‚Äî';
            document.getElementById('modal-transliteration').textContent = verse.transliteration || '‚Äî';
            document.getElementById('modal-translation').textContent = verse.translation_griffith || '‚Äî';
            
            updateNavigationButtons();
            
            const modal = document.getElementById('modal');
            modal.style.display = 'flex';
            setTimeout(() => modal.classList.add('show'), 10);
            
            document.querySelectorAll('.tag-pill').forEach(pill => {
                pill.addEventListener('click', () => {
                    const type = pill.dataset.type;
                    const label = pill.dataset.label;
                    closeModal();
                    setTimeout(() => {
                        const nodeId = type === 'deity' ? `deity-${label}` : 
                                     type === 'mood' ? `mood-${label}` : 
                                     `tag-${label}`;
                        const targetNode = networkData.nodes.find(n => n.id === nodeId);
                        if (targetNode) {
                            zoomToNode(targetNode);
                            setTimeout(() => highlightNode(targetNode), 500);
                        }
                    }, 300);
                });
            });
        }

        function closeModal() {
            const modal = document.getElementById('modal');
            modal.classList.remove('show');
            setTimeout(() => modal.style.display = 'none', 300);
        }

        function getSortedVerses() {
            return verses.slice().sort((a, b) => {
                if (a.mandala !== b.mandala) return a.mandala - b.mandala;
                if (a.sukta !== b.sukta) return a.sukta - b.sukta;
                return a.verse - b.verse;
            });
        }

        function updateNavigationButtons() {
            if (!currentVerse) return;
            
            const sorted = getSortedVerses();
            const currentIndex = sorted.findIndex(v => 
                v.mandala === currentVerse.mandala && 
                v.sukta === currentVerse.sukta && 
                v.verse === currentVerse.verse
            );
            
            const prevBtn = document.getElementById('prev-verse');
            const nextBtn = document.getElementById('next-verse');
            
            if (prevBtn) prevBtn.disabled = currentIndex <= 0;
            if (nextBtn) nextBtn.disabled = currentIndex >= sorted.length - 1;
        }

        function navigateVerse(direction) {
            if (!currentVerse) return;
            
            const sorted = getSortedVerses();
            const currentIndex = sorted.findIndex(v => 
                v.mandala === currentVerse.mandala && 
                v.sukta === currentVerse.sukta && 
                v.verse === currentVerse.verse
            );
            
            let newIndex;
            if (direction === 'prev') {
                newIndex = Math.max(0, currentIndex - 1);
            } else if (direction === 'next') {
                newIndex = Math.min(sorted.length - 1, currentIndex + 1);
            } else if (direction === 'random') {
                do {
                    newIndex = Math.floor(Math.random() * sorted.length);
                } while (newIndex === currentIndex && sorted.length > 1);
            }
            
            if (sorted[newIndex]) {
                openVerseModal(sorted[newIndex]);
            }
        }

        function zoomToNode(targetNode) {
            if (!targetNode) return;
            
            const width = window.innerWidth;
            const height = window.innerHeight;
            const scale = 2;
            const x = -targetNode.x * scale + width / 2;
            const y = -targetNode.y * scale + height / 2;
            
            svg.transition()
                .duration(500)
                .call(zoomBehavior.transform, d3.zoomIdentity.translate(x, y).scale(scale));
        }

        let searchTimeout;
        document.getElementById('search-input').addEventListener('input', (e) => {
            clearTimeout(searchTimeout);
            const query = e.target.value.trim().toLowerCase();
            
            if (query.length < 2) {
                document.getElementById('autocomplete').classList.add('hidden');
                return;
            }
            
            searchTimeout = setTimeout(() => {
                const results = [];
                
                searchIndex.deities.forEach((count, deity) => {
                    if (deity.toLowerCase().includes(query)) {
                        const emoji = deityEmojis[deity] || 'üî•';
                        results.push({ emoji, label: deity, count, type: 'deity' });
                    }
                });
                
                searchIndex.moods.forEach((count, mood) => {
                    if (mood.toLowerCase().includes(query)) {
                        const emoji = moodEmojis[mood] || '‚ú®';
                        results.push({ emoji, label: mood, count, type: 'mood' });
                    }
                });
                
                searchIndex.tags.forEach((count, tag) => {
                    if (tag.toLowerCase().includes(query)) {
                        results.push({ emoji: 'üè∑Ô∏è', label: tag, count, type: 'tag' });
                    }
                });
                
                results.sort((a, b) => b.count - a.count);
                const top8 = results.slice(0, 8);
                
                const autocomplete = document.getElementById('autocomplete');
                if (top8.length === 0) {
                    autocomplete.innerHTML = '<div class="autocomplete-item">No results found</div>';
                } else {
                    autocomplete.innerHTML = top8.map(r => 
                        `<div class="autocomplete-item" data-type="${r.type}" data-label="${r.label}">
                            ${r.emoji} ${r.label} (${r.count} verses)
                        </div>`
                    ).join('');
                    
                    autocomplete.querySelectorAll('.autocomplete-item').forEach(item => {
                        item.addEventListener('click', () => {
                            const type = item.dataset.type;
                            const label = item.dataset.label;
                            document.getElementById('search-input').value = '';
                            autocomplete.classList.add('hidden');
                            
                            const nodeId = `${type}-${label}`;
                            const targetNode = networkData.nodes.find(n => n.id === nodeId);
                            if (targetNode) {
                                zoomToNode(targetNode);
                                setTimeout(() => highlightNode(targetNode), 500);
                            }
                        });
                    });
                }
                
                autocomplete.classList.remove('hidden');
            }, 300);
        });

        document.addEventListener('click', (e) => {
            if (!e.target.closest('#search-input') && !e.target.closest('#autocomplete')) {
                document.getElementById('autocomplete').classList.add('hidden');
            }
            if (!e.target.closest('.node') && !e.target.closest('.modal-overlay')) {
                resetView();
            }
        });

        document.getElementById('close-modal').addEventListener('click', closeModal);
        document.getElementById('prev-verse').addEventListener('click', () => navigateVerse('prev'));
        document.getElementById('next-verse').addEventListener('click', () => navigateVerse('next'));
        document.getElementById('random-verse').addEventListener('click', () => navigateVerse('random'));

        document.getElementById('modal').addEventListener('click', (e) => {
            if (e.target.id === 'modal') {
                closeModal();
            }
        });

        document.addEventListener('keydown', (e) => {
            const modal = document.getElementById('modal');
            if (modal.style.display === 'flex') {
                if (e.key === 'Escape') closeModal();
                if (e.key === 'ArrowLeft' && !document.getElementById('prev-verse').disabled) {
                    e.preventDefault();
                    navigateVerse('prev');
                }
                if (e.key === 'ArrowRight' && !document.getElementById('next-verse').disabled) {
                    e.preventDefault();
                    navigateVerse('next');
                }
                if (e.key === ' ') {
                    e.preventDefault();
                    navigateVerse('random');
                }
            }
        });

        document.getElementById('zoom-in').addEventListener('click', () => {
            svg.transition().call(zoomBehavior.scaleBy, 1.3);
        });

        document.getElementById('zoom-out').addEventListener('click', () => {
            svg.transition().call(zoomBehavior.scaleBy, 0.7);
        });

        document.getElementById('reset-view').addEventListener('click', () => {
            resetView();
            svg.transition().call(zoomBehavior.transform, d3.zoomIdentity);
        });

        document.querySelectorAll('.legend-item').forEach(item => {
            item.addEventListener('click', () => {
                const filterType = item.dataset.type;
                
                node.classed('faded', d => d.type !== filterType);
                link.classed('faded', true);
                
                document.getElementById('reset-filter').classList.remove('hidden');
            });
        });

        document.getElementById('reset-filter').addEventListener('click', () => {
            resetView();
        });

        if (isMobile) {
            document.addEventListener('touchstart', () => {
                lastTouchTime = Date.now();
            });
        }

        window.addEventListener('resize', () => {
            const newIsMobile = window.innerWidth < 768;
            if (newIsMobile !== isMobile) {
                isMobile = newIsMobile;
                if (isMobile && !driftAnimationFrame) {
                    startMobileDrift();
                } else if (!isMobile && driftAnimationFrame) {
                    cancelAnimationFrame(driftAnimationFrame);
                    driftAnimationFrame = null;
                }
            }
        });

        loadData();
    </script>
</body>
</html>
