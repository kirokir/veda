<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üïâÔ∏è Rig Veda Mood Explorer</title>
    
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Noto+Serif+Devanagari:wght@400;600&display=swap" rel="stylesheet">
    <link rel="icon" href="data:;base64,iVBORw0KGgo=">

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Inter', sans-serif; background: #0A0E27; color: #fff; overflow: hidden; }
        .devanagari { font-family: 'Noto Serif Devanagari', serif; }
        #network-container { width: 100vw; height: 100vh; position: relative; }
        .node { cursor: pointer; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); }
        .node:hover { transform: scale(1.15); filter: drop-shadow(0 0 8px currentColor); }
        .node.active { animation: pulse 0.6s ease-in-out 3; }
        .link { stroke: rgba(255, 255, 255, 0.1); stroke-width: 0.5px; transition: all 0.3s ease; }
        .link.active { stroke: #D4AF37; stroke-width: 1.5px; opacity: 0.8; filter: drop-shadow(0 0 4px #D4AF37); }
        .link.faded { opacity: 0.05; }
        .node.faded { opacity: 0.1; }
        .network-label { font-size: 10px; fill: #ccc; pointer-events: none; user-select: none; text-shadow: 0 0 3px #000; }
        @keyframes pulse { 0%, 100% { transform: scale(1.3); } 50% { transform: scale(1.5); } }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        @keyframes pulseOpacity { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        .loading-spinner { animation: spin 1.5s linear infinite, pulseOpacity 1.5s ease-in-out infinite; font-size: 4rem; }
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); backdrop-filter: blur(10px); display: flex; align-items: center; justify-content: center; z-index: 1000; opacity: 0; transition: opacity 0.3s ease; pointer-events: none; }
        .modal-overlay.show { opacity: 1; pointer-events: auto; }
        .modal-content { background: linear-gradient(135deg, #1a1f3a, #0f1229); border: 1px solid rgba(212, 175, 55, 0.3); border-radius: 16px; padding: 2rem; max-width: 700px; width: 90%; max-height: 90vh; overflow-y: auto; transform: scale(0.9); transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); }
        .modal-overlay.show .modal-content { transform: scale(1); }
        .tag-pill { display: inline-block; padding: 0.25rem 0.75rem; background: rgba(212, 175, 55, 0.2); border: 1px solid rgba(212, 175, 55, 0.4); border-radius: 12px; font-size: 0.875rem; margin: 0.25rem; cursor: pointer; transition: all 0.2s ease; }
        .tag-pill:hover { background: rgba(212, 175, 55, 0.3); transform: translateY(-2px); }
        .autocomplete { position: absolute; background: #1a1f3a; border: 1px solid rgba(212, 175, 55, 0.3); border-radius: 8px; margin-top: 0.5rem; max-height: 300px; overflow-y: auto; z-index: 100; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5); }
        .autocomplete-item { padding: 0.75rem 1rem; cursor: pointer; transition: background 0.2s ease; border-bottom: 1px solid rgba(255, 255, 255, 0.1); }
        .autocomplete-item:hover { background: rgba(212, 175, 55, 0.2); }
        .legend { position: fixed; bottom: 2rem; left: 2rem; background: rgba(26, 31, 58, 0.7); backdrop-filter: blur(10px); border: 1px solid rgba(212, 175, 55, 0.3); border-radius: 12px; padding: 1rem; z-index: 50; }
        .legend-item { display: flex; align-items: center; gap: 0.5rem; margin: 0.5rem 0; cursor: pointer; transition: all 0.2s ease; }
        .legend-item:hover { transform: translateX(4px); }
        .legend-color { width: 16px; height: 16px; border-radius: 50%; }
        .network-controls { position: fixed; top: 6rem; right: 2rem; display: flex; flex-direction: column; gap: 0.5rem; z-index: 50; }
        .control-btn { background: rgba(26, 31, 58, 0.7); backdrop-filter: blur(10px); border: 1px solid rgba(212, 175, 55, 0.3); color: #D4AF37; width: 40px; height: 40px; border-radius: 8px; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s ease; font-weight: 600; }
        .control-btn:hover { background: rgba(26, 31, 58, 1); transform: scale(1.1); }
        @media (max-width: 768px) { .modal-content { width: 100%; height: 100%; max-height: 100vh; border-radius: 0; padding: 1.5rem; } .legend { bottom: 1rem; left: 1rem; font-size: 0.875rem; } .network-controls { top: 5rem; right: 1rem; } }
        .btn-primary { background: linear-gradient(135deg, #D4AF37, #FFD93D); color: #0A0E27; padding: 0.75rem 1.5rem; border-radius: 8px; border: none; cursor: pointer; font-weight: 600; transition: all 0.2s ease; }
        .btn-primary:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(212, 175, 55, 0.4); }
        .btn-primary:disabled { opacity: 0.4; cursor: not-allowed; }
        .btn-secondary { background: rgba(212, 175, 55, 0.2); color: #D4AF37; padding: 0.75rem 1.5rem; border-radius: 8px; border: 1px solid rgba(212, 175, 55, 0.4); cursor: pointer; font-weight: 500; transition: all 0.2s ease; }
        .btn-secondary:hover { background: rgba(212, 175, 55, 0.3); }
        .tooltip { position: absolute; background: rgba(26, 31, 58, 0.95); border: 1px solid rgba(212, 175, 55, 0.5); padding: 0.5rem 1rem; border-radius: 6px; font-size: 0.875rem; pointer-events: none; z-index: 1000; opacity: 0; transition: opacity 0.2s ease; }
        .tooltip.show { opacity: 1; }
        .hidden { display: none !important; } /* Ensure hidden utility class is respected */
        .network-label { fill: #ccc; text-shadow: 0 0 3px #000; } /* Set default label color and shadow */
    </style>
</head>
<body>
    <div id="app">
        <header class="fixed top-0 left-0 right-0 bg-gradient-to-r from-indigo-900/50 to-purple-900/50 backdrop-blur-md border-b border-yellow-600/30 z-40">
            <div class="container mx-auto px-4 py-4">
                <h1 class="text-2xl font-semibold text-center mb-3">üïâÔ∏è Rig Veda Mood Explorer</h1>
                <div class="max-w-2xl mx-auto relative">
                    <input type="text" id="search-input" placeholder="Search by deity, mood, or tag..." class="w-full px-4 py-2 rounded-lg bg-white/10 border border-yellow-600/30 text-white placeholder-gray-400 focus:outline-none focus:border-yellow-500 transition" />
                    <div id="autocomplete" class="autocomplete hidden"></div>
                </div>
            </div>
        </header>

        <div id="network-container"></div>

        <div class="legend">
            <div class="legend-item" data-type="deity"><div class="legend-color" style="background: linear-gradient(135deg, #FF6B6B, #FF8E53);"></div><span>üî¥ Deities</span></div>
            <div class="legend-item" data-type="mood"><div class="legend-color" style="background: linear-gradient(135deg, #FFD93D, #D4AF37);"></div><span>üü° Moods</span></div>
            <div class="legend-item" data-type="tag"><div class="legend-color" style="background: linear-gradient(135deg, #4A90E2, #6BCB77);"></div><span>üîµ Tags</span></div>
            <div class="legend-item" data-type="verse"><div class="legend-color" style="background: #F5F5F5; border: 2px solid #D4AF37;"></div><span>‚ö™ Verses</span></div>
            <button id="reset-filter" class="btn-secondary w-full mt-2 hidden text-sm">Reset Filter</button>
        </div>

        <div class="network-controls">
            <button class="control-btn" id="zoom-in">+</button>
            <button class="control-btn" id="zoom-out">‚àí</button>
            <button class="control-btn" id="reset-view" style="width: auto; padding: 0 0.75rem;">‚Ü∫</button>
        </div>

        <div id="loading" class="fixed inset-0 flex items-center justify-center flex-col gap-4 z-50 bg-gradient-to-br from-indigo-900 to-purple-900">
            <div class="loading-spinner">üïâÔ∏è</div>
            <div id="loading-text" class="text-xl">Loading Rig Veda...</div>
        </div>

        <div id="modal" class="modal-overlay" style="display: none;">
            <div class="modal-content">
                <button id="close-modal" class="absolute top-4 right-4 text-3xl text-gray-400 hover:text-white transition">&times;</button>
                <div id="modal-header" class="text-center mb-4 text-lg text-yellow-500"></div>
                <div id="modal-tags" class="flex flex-wrap justify-center mb-6"></div>
                <div id="modal-devanagari" class="devanagari text-3xl text-center mb-4 leading-relaxed"></div>
                <div id="modal-transliteration" class="italic text-gray-400 text-xl text-center mb-6"></div>
                <div id="modal-translation" class="text-lg leading-relaxed mb-8"></div>
                <div class="flex gap-3 justify-center items-center flex-wrap">
                    <button id="prev-verse" class="btn-secondary">‚Üê Previous</button>
                    <button id="random-verse" class="btn-primary">üé≤ Dice of Destiny</button>
                    <button id="next-verse" class="btn-secondary">Next ‚Üí</button>
                </div>
            </div>
        </div>

        <div class="tooltip" id="tooltip"></div>
    </div>

    <script>
        // --- Global State ---
        let verses = [];
        let searchIndex = { deities: new Map(), moods: new Map(), tags: new Map() };
        let networkData = { nodes: [], links: [] };
        let simulation, svg, g, link, node, labels; // Declare labels here
        let currentVerse = null;
        let selectedNode = null;
        let isMobile = window.innerWidth < 768;
        let driftAnimationFrame = null;
        let lastTouchTime = 0;
        let transform = d3.zoomIdentity;
        let zoomBehavior; // Declare zoomBehavior here
        
        // --- Emojis for Search ---
        const deityEmojis = { 'Agni': 'üî•', 'Indra': '‚ö°', 'Soma': 'üåô', 'Ushas': 'üåÖ', 'Vayu': 'üí®', 'Varuna': 'üåä', 'Surya': '‚òÄÔ∏è', 'Vishnu': 'ü¶Ö', 'Rudra': 'üèπ', 'Maruts': '‚õàÔ∏è', 'Ashvins': 'üêé', 'Sarasvati': 'üìø' };
        const moodEmojis = { 'invocatory': 'üôè', 'praise': '‚ú®', 'contemplative': 'üí≠', 'devotional': 'üïâÔ∏è', 'philosophical': 'üßò', 'narrative': 'üìú', 'healing': 'üåø', 'victorious': 'üèÜ' };

        async function main() {
            try {
                document.getElementById('loading-text').textContent = 'Loading verses...';
                // CRITICAL FIX: Load the correct, final augmented data file.
                const response = await fetch('./rigveda_data_augmented.json');
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                verses = await response.json();
                
                if (!Array.isArray(verses) || verses.length === 0) {
                    throw new Error('Invalid data format: JSON is empty or not an array.');
                }

                document.getElementById('loading-text').textContent = 'Building search index...';
                buildSearchIndex();
                
                document.getElementById('loading-text').textContent = 'Creating network visualization...';
                createNetwork();
                
                document.getElementById('loading').style.display = 'none';
            } catch (error) {
                console.error("Fatal Error:", error);
                document.getElementById('loading-text').textContent = `Unable to load data. Error: ${error.message}. Please ensure rigveda_data_augmented.json was uploaded correctly.`;
                document.getElementById('loading').innerHTML += `<button onclick="location.reload()" class="btn-primary mt-4">Retry</button>`;
            }
        }
    
        function buildSearchIndex() {
            verses.forEach(verse => {
                if (verse.deity) searchIndex.deities.set(verse.deity, (searchIndex.deities.get(verse.deity) || 0) + 1);
                if (verse.mood) searchIndex.moods.set(verse.mood, (searchIndex.moods.get(verse.mood) || 0) + 1);
                if (verse.tags && Array.isArray(verse.tags)) {
                    verse.tags.forEach(tag => searchIndex.tags.set(tag, (searchIndex.tags.get(tag) || 0) + 1));
                }
            });
        }
    
        function createNetwork() {
            const nodes = [];
            const links = [];
            const nodeMap = new Map();
    
            const topTags = [...searchIndex.tags.entries()].sort((a, b) => b[1] - a[1]).slice(0, 50);
    
            searchIndex.deities.forEach((count, deity) => {
                const id = `deity-${deity}`;
                nodes.push({ id, type: 'deity', label: deity, count });
                nodeMap.set(id, nodes[nodes.length - 1]);
            });
            
            searchIndex.moods.forEach((count, mood) => {
                const id = `mood-${mood}`;
                nodes.push({ id, type: 'mood', label: mood, count });
                nodeMap.set(id, nodes[nodes.length - 1]);
            });
            
            topTags.forEach(([tag, count]) => {
                const id = `tag-${tag}`;
                nodes.push({ id, type: 'tag', label: tag, count });
                nodeMap.set(id, nodes[nodes.length - 1]);
            });
            
            // IMPORTANT: Use ALL verses to build the network for a complete visualization.
            verses.forEach(verse => {
                const id = `verse-${verse.mandala}-${verse.sukta}-${verse.verse}`;
                nodes.push({ id, type: 'verse', verse });
                nodeMap.set(id, nodes[nodes.length - 1]);
    
                if (verse.deity && nodeMap.has(`deity-${verse.deity}`)) links.push({ source: id, target: `deity-${verse.deity}` });
                if (verse.mood && nodeMap.has(`mood-${verse.mood}`)) links.push({ source: id, target: `mood-${verse.mood}` });
                if (verse.tags) {
                    verse.tags.forEach(tag => {
                        if (nodeMap.has(`tag-${tag}`)) links.push({ source: id, target: `tag-${tag}` });
                    });
                }
            });
    
            networkData = { nodes, links };
            initializeVisualization();
        }
    
        function initializeVisualization() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            svg = d3.select('#network-container').append('svg').attr('width', width).attr('height', height);
            
            const defs = svg.append('defs');
            const gradients = [
                { id: 'deity-gradient', c1: '#FF6B6B', c2: '#FF8E53' },
                { id: 'mood-gradient', c1: '#FFD93D', c2: '#D4AF37' },
                { id: 'tag-gradient', c1: '#4A90E2', c2: '#6BCB77' },
            ];
            gradients.forEach(grad => {
                const gradient = defs.append('linearGradient').attr('id', grad.id).attr('x1', '0%').attr('y1', '0%').attr('x2', '100%').attr('y2', '100%');
                gradient.append('stop').attr('offset', '0%').attr('stop-color', grad.c1);
                gradient.append('stop').attr('offset', '100%').attr('stop-color', grad.c2);
            });
            
            zoomBehavior = d3.zoom().scaleExtent([0.1, 8]).on('zoom', (event) => {
                transform = event.transform;
                g.attr('transform', transform);
            });
            svg.call(zoomBehavior);
            
            g = svg.append('g');
            
            simulation = d3.forceSimulation(networkData.nodes)
                .force('link', d3.forceLink(networkData.links).id(d => d.id).distance(40).strength(0.6))
                .force('charge', d3.forceManyBody().strength(-90))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collide', d3.forceCollide().radius(15));
            
            link = g.append('g').selectAll('line').data(networkData.links).join('line').attr('class', 'link');
            
            node = g.append('g').selectAll('circle').data(networkData.nodes).join('circle')
                .attr('class', 'node')
                .attr('r', d => d.type === 'deity' ? 12 : d.type === 'mood' ? 10 : d.type === 'tag' ? 8 : 5)
                .attr('fill', d => d.type === 'deity' ? 'url(#deity-gradient)' : d.type === 'mood' ? 'url(#mood-gradient)' : d.type === 'tag' ? 'url(#tag-gradient)' : '#F5F5F5')
                .attr('stroke', d => d.type === 'verse' ? '#D4AF37' : 'none').attr('stroke-width', 1.5)
                .on('click', handleNodeClick)
                .on('mouseenter', handleNodeHover)
                .on('mouseleave', hideTooltip)
                .call(d3.drag().on('start', dragStarted).on('drag', dragged).on('end', dragEnded));
            
            labels = g.append('g').selectAll('text')
                .data(networkData.nodes.filter(d => d.type !== 'verse'))
                .join('text')
                .attr('class', 'network-label')
                .text(d => d.label)
                .on('click', handleNodeClick)
                .on('mouseenter', handleNodeHover)
                .on('mouseleave', hideTooltip);
            
            simulation.on('tick', () => {
                link.attr('x1', d => d.source.x).attr('y1', d => d.source.y).attr('x2', d => d.target.x).attr('y2', d => d.target.y);
                node.attr('cx', d => d.x).attr('cy', d => d.y);
                labels.attr('x', d => d.x + 15).attr('y', d => d.y + 4);
            });
            
            setupUIEvents();
            if (isMobile) startMobileDrift(); // Start drift on mobile immediately
        }
        
        function handleNodeClick(event, d) {
            if (d.type === 'verse') openVerseModal(d.verse);
            else selectedNode === d ? resetViewHighlights() : highlightConnections(d);
        }
        
        function highlightConnections(d) {
            selectedNode = d;
            const connectedNodes = new Set([d.id]);
            networkData.links.forEach(l => {
                const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
                const targetId = typeof l.target === 'object' ? l.target.id : l.target;
                
                if (sourceId === d.id) connectedNodes.add(targetId);
                if (targetId === d.id) connectedNodes.add(sourceId);
            });
            
            node.classed('active', n => n.id === d.id).classed('faded', n => !connectedNodes.has(n.id));
            link.classed('active', l => connectedNodes.has(typeof l.source === 'object' ? l.source.id : l.source) && connectedNodes.has(typeof l.target === 'object' ? l.target.id : l.target)).classed('faded', l => !(connectedNodes.has(typeof l.source === 'object' ? l.source.id : l.source) && connectedNodes.has(typeof l.target === 'object' ? l.target.id : l.target)));
            
            labels.classed('faded', l => !connectedNodes.has(typeof l.id === 'object' ? l.id : l.id)); // Fix for labels
            document.getElementById('reset-filter').classList.remove('hidden');
        }
    
        function resetViewHighlights() {
            selectedNode = null;
            node.classed('active', false).classed('faded', false);
            link.classed('active', false).classed('faded', false);
            labels.classed('faded', false); // Ensure labels are also reset
            hideTooltip();
            document.getElementById('reset-filter').classList.add('hidden');
        }
        
        function openVerseModal(verse) {
            currentVerse = verse;
            document.getElementById('modal-header').textContent = `Mandala ${verse.mandala} ‚Ä¢ Sukta ${verse.sukta} ‚Ä¢ Verse ${verse.verse}`;
            
            const tagPills = [];
            if (verse.deity) tagPills.push(`<span class="tag-pill" data-type="deity" data-label="${verse.deity}">${verse.deity}</span>`);
            if (verse.mood) tagPills.push(`<span class="tag-pill" data-type="mood" data-label="${verse.mood}">${verse.mood}</span>`);
            if (verse.categorization) tagPills.push(`<span class="tag-pill" data-type="categorization" data-label="${verse.categorization}">${verse.categorization}</span>`); // Add categorization to pills
            if (verse.tags && verse.tags.length > 0) verse.tags.forEach(t => tagPills.push(`<span class="tag-pill" data-type="tag" data-label="${t}">${t}</span>`));
            document.getElementById('modal-tags').innerHTML = tagPills.join('');
    
            document.getElementById('modal-devanagari').textContent = verse.devanagari || '‚Äî';
            document.getElementById('modal-transliteration').textContent = verse.transliteration || '‚Äî';
            document.getElementById('modal-translation').textContent = verse.translation_griffith || '‚Äî';
            
            updateNavButtons();
    
            const modal = document.getElementById('modal');
            modal.style.display = 'flex';
            setTimeout(() => modal.classList.add('show'), 10);

            // Re-attach event listeners for dynamically added tag pills
            document.querySelectorAll('#modal-tags .tag-pill').forEach(pill => {
                pill.addEventListener('click', () => {
                    const type = pill.dataset.type;
                    const label = pill.dataset.label;
                    closeModal();
                    setTimeout(() => {
                        const nodeId = `${type}-${label}`;
                        const targetNode = networkData.nodes.find(n => n.id === nodeId);
                        if (targetNode) {
                            zoomToNode(targetNode);
                            setTimeout(() => highlightConnections(targetNode), 500);
                        }
                    }, 300);
                });
            });
        }
        
        function closeModal() {
            const modal = document.getElementById('modal');
            modal.classList.remove('show');
            setTimeout(() => { modal.style.display = 'none'; }, 300);
        }
        
        const getSortedVerses = () => verses.slice().sort((a, b) => a.mandala !== b.mandala ? a.mandala - b.mandala : a.sukta !== b.sukta ? a.sukta - b.sukta : a.verse - b.verse);
        
        function updateNavButtons() {
            if (!currentVerse) return;
            const sorted = getSortedVerses();
            const currentIndex = sorted.findIndex(v => v.mandala === currentVerse.mandala && v.sukta === currentVerse.sukta && v.verse === currentVerse.verse);
            document.getElementById('prev-verse').disabled = currentIndex <= 0;
            document.getElementById('next-verse').disabled = currentIndex >= sorted.length - 1;
        }
    
        function navigateVerse(direction) {
            if (!currentVerse) return;
            const sorted = getSortedVerses();
            const currentIndex = sorted.findIndex(v => v.mandala === currentVerse.mandala && v.sukta === currentVerse.sukta && v.verse === currentVerse.verse);
            let newIndex;
            if (direction === 'prev') newIndex = Math.max(0, currentIndex - 1);
            else if (direction === 'next') newIndex = Math.min(sorted.length - 1, currentIndex + 1);
            else if (direction === 'random') {
                do { newIndex = Math.floor(Math.random() * sorted.length); } while (newIndex === currentIndex && sorted.length > 1);
            }
            if (sorted[newIndex]) openVerseModal(sorted[newIndex]);
        }
    
        const handleNodeHover = (event, d) => !isMobile && showTooltip(event, `${d.label || 'Verse'} ${d.count ? `(${d.count})` : ''}`);
        const showTooltip = (event, text) => d3.select('#tooltip').style('left', `${event.pageX + 15}px`).style('top', `${event.pageY}px`).text(text).classed('show', true);
        const hideTooltip = () => d3.select('#tooltip').classed('show', false);
        const dragStarted = (event) => { if (!event.active) simulation.alphaTarget(0.3).restart(); event.subject.fx = event.subject.x; event.subject.fy = event.subject.y; };
        const dragged = (event) => { event.subject.fx = event.x; event.subject.fy = event.y; };
        const dragEnded = (event) => { if (!event.active) simulation.alphaTarget(0); event.subject.fx = null; event.subject.fy = null; };
    
        function setupUIEvents() {
            document.getElementById('search-input').addEventListener('input', handleSearch);
            document.getElementById('close-modal').addEventListener('click', closeModal);
            document.getElementById('prev-verse').addEventListener('click', () => navigateVerse('prev'));
            document.getElementById('next-verse').addEventListener('click', () => navigateVerse('next'));
            document.getElementById('random-verse').addEventListener('click', () => navigateVerse('random'));
            document.addEventListener('keydown', e => {
                const modal = document.getElementById('modal');
                if (modal.classList.contains('show')) {
                    if (e.key === 'Escape') closeModal();
                    if (e.key === 'ArrowLeft' && !document.getElementById('prev-verse').disabled) { e.preventDefault(); navigateVerse('prev'); }
                    if (e.key === 'ArrowRight' && !document.getElementById('next-verse').disabled) { e.preventDefault(); navigateVerse('next'); }
                    if (e.key === ' ') { e.preventDefault(); navigateVerse('random'); }
                }
            });
            document.getElementById('zoom-in').addEventListener('click', () => svg.transition().call(zoomBehavior.scaleBy, 1.3));
            document.getElementById('zoom-out').addEventListener('click', () => svg.transition().call(zoomBehavior.scaleBy, 0.7));
            document.getElementById('reset-view').addEventListener('click', () => { resetViewHighlights(); svg.transition().call(zoomBehavior.transform, d3.zoomIdentity); });
    
            document.querySelectorAll('.legend-item').forEach(item => {
                item.addEventListener('click', () => {
                    const filterType = item.dataset.type;
                    node.classed('faded', d => d.type !== filterType);
                    link.classed('faded', l => !( (typeof l.source === 'object' ? l.source.type : l.source.startsWith(filterType)) || (typeof l.target === 'object' ? l.target.type : l.target.startsWith(filterType)) ));
                    labels.classed('faded', l => l.type !== filterType);
                    document.getElementById('reset-filter').classList.remove('hidden');
                });
            });
    
            document.getElementById('reset-filter').addEventListener('click', resetViewHighlights); // Now reset to full view
            if (isMobile) {
                document.addEventListener('touchstart', () => { lastTouchTime = Date.now(); });
            }
            window.addEventListener('resize', () => {
                const newIsMobile = window.innerWidth < 768;
                if (newIsMobile !== isMobile) {
                    isMobile = newIsMobile;
                    if (isMobile && !driftAnimationFrame) startMobileDrift();
                    else if (!isMobile && driftAnimationFrame) { cancelAnimationFrame(driftAnimationFrame); driftAnimationFrame = null; }
                }
            });
        }
    
        function handleSearch(e) {
            const query = e.target.value.trim().toLowerCase();
            const autocomplete = document.getElementById('autocomplete');
            if (query.length < 2) { autocomplete.classList.add('hidden'); return; }
            
            const results = [];
            searchIndex.deities.forEach((c, l) => l.toLowerCase().includes(query) && results.push({ type: 'deity', label: l, count: c, emoji: deityEmojis[l] || 'üî•' }));
            searchIndex.moods.forEach((c, l) => l.toLowerCase().includes(query) && results.push({ type: 'mood', label: l, count: c, emoji: moodEmojis[l] || '‚ú®' }));
            searchIndex.tags.forEach((c, l) => l.toLowerCase().includes(query) && results.push({ type: 'tag', label: l, count: c, emoji: 'üè∑Ô∏è' }));
            
            const topResults = results.sort((a, b) => b.count - a.count).slice(0, 8);
            
            autocomplete.innerHTML = !topResults.length ? `<div class="autocomplete-item">No results found</div>` : topResults.map(r => 
                `<div class="autocomplete-item" data-type="${r.type}" data-label="${r.label}">${r.emoji} ${r.label} (${r.count} verses)</div>`
            ).join('');
            
            autocomplete.querySelectorAll('.autocomplete-item').forEach(item => {
                item.addEventListener('click', () => {
                    const nodeId = `${item.dataset.type}-${item.dataset.label}`;
                    const targetNode = networkData.nodes.find(n => n.id === nodeId);
                    if (targetNode) { highlightConnections(targetNode); zoomToNode(targetNode); }
                    document.getElementById('search-input').value = '';
                    autocomplete.classList.add('hidden');
                });
            });
            autocomplete.classList.remove('hidden');
        }
        
        function zoomToNode(d) {
            const { x, y } = d;
            const scale = 1.5;
            const translate = [window.innerWidth / 2 - scale * x, window.innerHeight / 2 - scale * y];
            svg.transition().duration(750).call(
                d3.zoom().transform,
                d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale)
            );
        }
        
        function startMobileDrift() {
            let startTime = Date.now();
            
            function drift() {
                const now = Date.now();
                const elapsed = (now - startTime) / 1000;
                const timeSinceTouch = (now - lastTouchTime) / 1000;
                
                if (timeSinceTouch > 3) {
                    const offsetX = Math.sin(elapsed * 0.5) * 20;
                    const offsetY = Math.cos(elapsed * 0.3) * 15;
                    
                    const newTransform = d3.zoomIdentity
                        .translate(offsetX, offsetY)
                        .scale(zoomBehavior.transform().k); // Use current scale
                    
                    svg.call(zoomBehavior.transform, newTransform);
                }
                driftAnimationFrame = requestAnimationFrame(drift);
            }
            if (driftAnimationFrame) cancelAnimationFrame(driftAnimationFrame); // Clear any old animation
            driftAnimationFrame = requestAnimationFrame(drift);
        }

        document.addEventListener('DOMContentLoaded', main);
    </script>
</body>
</html>